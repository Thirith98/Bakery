#+Title: OS Project - Fribourgeois Bakery
#+Author: Group 1: Gabriel, Odermatt, Wey & Yang
#+options: \n:t
#+LATEX: \setlength\parindent{0pt}

* Introduction

The present documentation reports on the solution to the /Fribourgeois Bakery/ project elaborated by Group 1.

The discussion of the solution will be structured as follows: Chapter one will present the datastructure that represents our inventory as well as our solution to the task "Learning to make bread". Chapter two will focus on "Too good to go" and chapter four will present our additional feature. Our implementation decisions as well as the scenarios will be discussed in chapter one.

* Inventory and Making Bread

** Inventory
- Binary tree where each node represents an ingredient type. Each of those nodes holds a linked list where each node represents one unit of that ingredient type.
- Building and searching of tree: Tree is lexographically sorted -- meaning that that the left child of each parent node contains an ingredient type whose name is smaller and the right child contains an ingredient type whose name is bigger than the parents name. "Smaller" and "bigger" in this context refer to the ordering of characters proposed by the ASCII standard. Due to this strict ordering of ingredients, the tree can be traversed and searched very efficiently$\footnote{Strictly speaking this does not always have to be the case. If the ingredients happen to be added in ASCII order (or in reverse) then the tree would be a normal linked list and searching the tree would perform accordingly.}$.
- Traversal of the tree:
  + Iterativ oder rekursiv, richtig? (@Lukas). In getInvNode() ist es iterativ, in restock() ist es rekursiv.
- Useful functions provided:
  + registerIngredient()
  + addIngredient()
  + takeIngredient()
  + restock()
- Data structure size: Binary tree can grow in two dimensions: Regarding ingredient types and regarding ingredient units.
- Simultaneous access:
  + We chose to implement concurrency client-side, i.e. not in the datastructure itself but in the "Making bread" script.
  + We could have implemented mutual exclusion in the datastructure itself either on the entire datastructure or only on the linked list inside the ingredient node. However,

** Making Bread

- Synchronization:
  + Mutex: The inventory is mutexed.
  + Semaphore: Coordination between baker, apprentices and shopper.
- Scheduler Strategy:
  + When an apprentice wants to access the inventory they announce their interest in a global array by modifying the field at the index that corresponds to their id. Depending on the schedular metric used, they insert differnt values. Access to this array may be concurrent since every index can only be written by one apprentice.
  + Implemented four schedulers: (i) Predefined learners (ii) Arrival Order (based on time) (iii) Fast learners (apprentice with the most baked breads) (iv) Fairlearners (apprentice with the least baked breads).
  + Explain when each of the strategies performs best and worst.

** Scenarios
- Scenarios:
  + (i) Apprentices add the same item to the inventory: In func registerIngredient() we first check whether the ingredient has already been registered. If so, we restock to initial amount but do not add it again.
  + (ii) Apprentices access the same item in the inventory: Not possible by design, since the datastructure is made mutually exclusive and since we synchronize the apprentices using the baker as the schedular.
  + (iii) Same as (ii) except in this case we synchronize between apprentice and shopper. But the approach stays the same.

* Too Good To Go
- Analogy to NRU

* Additional Feature
- Chairs: Queue, mutexted.
- Synchronization: Semaphores (one for the baker and one for each chair).
